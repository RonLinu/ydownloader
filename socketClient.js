// Generated by CoffeeScript 2.7.0
(function() {
  /*
   This single function is executed on a browser client to handles the socket
   communication with a socket server running on Node.js.

   Its main purpose is to execute system commands and scripts with system
   level access using Node.js.

   There are few sub-functions provided to:
   - send a system command to be executed at server side
   - send a script code to be executed at server side
   - assign data to a server variable to be used by the script code (if needed)
   - read the return data of a system command or a script code execution
   - return the platform detected at server side, immune to browser spoofing
   - return the server version
   - update "live" the server script
  */
  var indexOf = [].indexOf;

  window.socketClient = function() {
    var exec, fragment, platform, read, ref, script, send, serverPlatform, serverReply, serverVersion, serversion, socket, socketPort, update;
    fragment = location.hash.split(',');
    if (fragment[0] === '#BUSY') {
      document.body.innerHTML = 'The application is already in use in another tab or browser';
      throw new Error('WebScoket already in use');
    } else if (fragment[0] === '#ERROR') {
      document.body.innerHTML = 'WebSocket connection error';
      throw new Error('WebSocket connection error');
    }
    serverVersion = fragment[0];
    serverPlatform = fragment[1];
    socketPort = fragment[2];
    serverReply = '';
    if ((ref = parseInt('0' + socketPort), indexOf.call((function() {
      var results = [];
      for (var i = 1024; i <= 49151; i++){ results.push(i); }
      return results;
    }).apply(this), ref) < 0) || (serverPlatform !== 'win32' && serverPlatform !== 'linux' && serverPlatform !== 'darwin')) {
      document.body.innerHTML = 'The application MUST be started by the WebSocket server.';
      console.log("Incorrect parameters", serverPlatform, socketPort);
      throw new Error(document.body.innerHTML);
    }
    socket = new WebSocket(`ws://localhost:${socketPort}/ws`);
    socket.onopen = function(event) {
      return console.log('WebSocket connection established');
    };
    socket.onclose = function(event) {
      console.log('WebSocket connection closed');
      return document.body.innerHTML = 'WebsScoket connection closed';
    };
    // ----------------------------------

    // Return the operating system name detected at the server side
    serversion = function() {
      return serverVersion;
    };
    platform = function() {
      return serverPlatform;
    };
    // Send a system command to be executed at server side
    exec = function(command, timeout = 5000) {
      var cmd;
      serverReply = '';
      cmd = JSON.stringify({
        action: 'exec',
        cmd: command,
        timeout: timeout
      });
      return socket.send(cmd);
    };
    // Send a CoffeeScript code (translated to JavaScript) to be executed
    // at server side with access to Node.js capabilities
    script = function(func, timeout = 5000) {
      var cmd, code;
      code = func.toString();
      serverReply = '';
      cmd = JSON.stringify({
        action: 'script',
        cmd: `(${code})();`,
        timeout: timeout
      });
      return socket.send(cmd);
    };
    // Send data (primitive or object) to server to be saved in the
    // 'data' server variable, usefull before calling script command
    send = function(data) {
      var cmd;
      cmd = JSON.stringify({
        action: 'send',
        cmd: data
      });
      return socket.send(cmd);
    };
    // Update "live" the WebSocket server script (experimental)
    update = function(data) {
      var cmd;
      cmd = JSON.stringify({
        action: 'update',
        cmd: data
      });
      return socket.send(cmd);
    };
    // Wait for server to finish execution of a system command or script
    // and return any result
    read = function(timeout = 5000) {
      return new Promise(function(resolve) {
        socket.onmessage = function(event) {
          return resolve(event.data.trim());
        };
        // Timeout in milliseconds
        return setTimeout(function() {
          return resolve('#TIMEOUT');
        }, timeout);
      });
    };
    return {serversion, platform, update, exec, script, send, read};
  };

}).call(this);
