// Generated by CoffeeScript 2.7.0
var WebSocket, activeClient, exec, fragmentId, launchBrowser, openBrowser, randomHex, shutdown, socketport, timeout, webpage, wss;

webpage = process.argv[2];

socketport = process.argv[3];

fragmentId = ''; // url fragment identifier

timeout = true; // delay for client to respond

activeClient = null; // only one client accepted at a time

if (socketport === '' || webpage === '') {
  console.log('Syntax: node websocket.js <web_app_url> <socket_port>');
  process.exit(0);
}

WebSocket = require('ws'); // to install: npm install ws

({exec} = require('child_process'));

wss = new WebSocket.Server({
  port: socketport
});

// --------------------------------------
wss._server.on('listening', function() {
  // Port opened successfully
  console.log('WebSocket server listening on port', socketport);
  // Client (browser) must respond within 10 sec or server will close
  setTimeout(shutdown, 10000);
  // Launch client (browser)
  fragmentId = '#' + randomHex() + ',' + process.platform + ',' + socketport;
  return launchBrowser(fragmentId);
});

// --------------------------------------
wss.on('error', function(err) {
  var firstline;
  if (err.code === 'EADDRINUSE') {
    console.error('Port', socketport, 'is already in use');
    return launchBrowser('#BUSY');
  } else {
    firstline = err.message.split('\n')[0];
    console.error('WebSocket server error:', firstline);
    return launchBrowser('#ERROR');
  }
});

// --------------------------------------
// When client connects
wss.on('connection', function(ws) {
  if (activeClient) {
    ws.close(1000, 'Only one client allowed at a time');
    return;
  }
  activeClient = ws;
  console.log('Client connected');
  timeout = false; // cancel automatic shutdown
  
  // When the client disconnects
  ws.on('close', function() {
    activeClient = null;
    console.log('Client disconnected');
    return process.exit(0);
  });
  ws.on('error', function() {
    activeClient = null;
    console.log('Client disconnected from error');
    return process.exit(0);
  });
  // When server receives a command from client
  return ws.on('message', function(message) {
    var values;
    values = JSON.parse(message);
    // Reject any command without correct fragment identifier
    if (values.id !== fragmentId) {
      console.error('Incorrect fragment identifier received');
      return;
    }
    switch (values.action) {
      case 'quit':
        console.log('Client disconnected on request');
        ws.close();
        return process.exit(0);
      case 'run':
        console.log('Server received:', values.cmd);
        return exec(values.cmd, function(error, stdout, stderr) {
          return ws.send(`${stdout} ~~~ ${stderr} ~~~ ${error}`);
        });
    }
  });
});

// ---------------------------------------------------------------------
openBrowser = function(url) {
  switch (process.platform) {
    case 'win32':
      return exec(`start ${url}`);
    case 'linux':
      return exec(`xdg-open '${url}'`);
    case 'darwin':
      return exec(`open '${url}'`);
    default:
      console.error('Unsupported operating system');
      return process.exit(1);
  }
};

// ----------------------------
randomHex = function() {
  return Math.floor(Math.random() * 0xFFFFFFFF).toString(16).padStart(8, '0'); // random 32-bit integer // convert to hex // ensure 8 characters
};


// --------------------------------------
launchBrowser = function(fragmentId) {
  console.log('Launching default browser at', webpage);
  return openBrowser(webpage + fragmentId);
};

// --------------------------------------
shutdown = function() {
  if (timeout) {
    console.log('Client did not respond in time. Server closed.');
    return process.exit(1);
  }
};
